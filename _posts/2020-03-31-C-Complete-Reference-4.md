---
layout: post
title: 《C语言大全第4版》笔记
categories: Programming
description: 
keywords: 
---

*前期的C语言自学笔记主要依据黑马程序员B站视频，因视频学习时间过长，故转战书本学习。章节之间不连续的原因是已熟知的章节没有做笔记。*

<!--more-->

## 第二章 C表达式

### 2.5 类型修饰符

#### 2.5.1 const

在形参前加`const`可以防止函数内部对原变量的修改。通常如果不希望函数修改实际参数，则会在形式参数前加`const`。

```c
#include <stdio.h>

void func(const char* s)
{
    //s[5] = 'I'; //会报错，但如果参数不加const，就能正常修改，输出"this Is a test"
}

int main(void)
{
    char str[15] = "this is a test";
    func(str);
    printf("%s\n", str);
    return 0;
}
```

如果使用指针修改，虽然目标字符可以修改成功，但修改部分以后的字符就无法输出了。

```c
#include <stdio.h>

void func(const char* s)
{
    int* p = &s[5];
    *p = 'I';
}

int main(void)
{
    char str[15] = "this is a test";
    func(str);
    printf("%s\n", str);
    return 0;
}
```

>   为什么呢？

#### 2.5.2 volatile

如果变量不出现在赋值号左边，则程序认为变量没有更改，则会优化后续某些用到该变量的表达式，比如直接用值替换掉，但有些变量是随硬件信息变化的（如时钟值），虽然程序没有修改，但其值也会变化。在此种变量前加`volatile`修饰符可以防止程序优化此类变量。

### 2.6 存储类型说明符

C有四种存储类型说明符，`extern`，`static`，`register`，`auto`。

#### 2.6.1 extern

C语言中有三种链接，**外部链接**，**内部链接**，**无链接**。通常函数和全局变量有外部链接，它们在程序的所有文件中都是可以使用的；用`static`修饰的变量有内部链接，只能在声明它的文件内使用；局部变量无链接，只在自己的块域内使用。

```c
#include <stdio.h>

int main(void)
{
    //如果此处不加extern，则定义了变量，却没有赋值，后续会报错
    //添加extern后，说明只声明变量，在别的地方定义，就不会报错
    extern int a, b;
    printf("a: %d, b: %d\n", a, b);
    return 0;
}
//此处只是因为定义放在了main函数之后，才需要加extern
int a = 10, b = 20;
```

**变量可以有很多声明，但只能有一个定义。**

`extern`主要用于多文件编译。比如一个文件使用的变量是在另一个文件里定义的，则在这个文件里就可以用`extern`声明一下变量，让程序去别的文件里找定义。

#### 2.6.2 static变量

```c
#include <stdio.h>

int series(void)
{
    //静态局部变量，能在多次调用这个函数时保持上一次修改的新值
    //本质是创建一个永久存储空间，不会在函数结束时毁灭
    //但仍然是局部变量，只在函数内可见
    static int num = 10;
    num = num + 10;
    return num;
}

int main(void)
{
    printf("%d\n", series());
    printf("%d\n", series());
    printf("%d\n", series());
    return 0;
}
```

对于静态全局变量，它只能对声明它的文件可见，因此不能从别的文件导入，省去了很多副作用。

#### 2.6.3 register变量

`register`将修饰的变量存在寄存器中而非内存中，所以加快了访问该变量的速度。但代码中可以得到寄存器优化的变量是有限的，超限的寄存器变量将会变为普通变量。

`register`只能用于**局部变量**和**函数形参**，全局寄存器变量是非法的。

虽然`register`已经得到扩展，但实际上它还是只对**整型**和**字符型**有实际作用。

用`register`修饰的变量不能用`&`寻址，因为寄存器无法编址。

### 2.9 操作符

#### 2.9.12 逗号(,)操作符

逗号连接一串表达式，逗号左边求值为`void`型，一串表达式的最右侧为整个表达式的值。

```c
#include <stdio.h>

int main(void)
{
    int x, y; //只能先定义
    int a = (x = 4, y = 7, x + y); //必须加括号，因为逗号的优先级比赋值号低
    printf("%d\n", a); //输出11
    return 0;
}
```

## 第三章 语句

### 3.3 重复(Iteration)语句

#### 3.3.1 for循环

for语句的一般形式：

```
for (initialization; condition; increment) statement;
```

一般来说，`initialization`是赋值语句，`condition`是条件表达式，`increment`定义每次循环后如何修改变量。理论上三者都是**可选的**。

程序的执行顺序：

```
initialization;
condition;
statement;
increment;
condition;
statement;
increment;
condition;
……
```

#### 3.3.3 无限循环

当条件表达式不存在时，则认为它是正确的。

```c
#include <stdio.h>

int main(void)
{
    for (;;) printf("run forever\n");
    return 0;
}
```

#### 3.3.5 在for循环中声明变量

以下例子**在C89中不合法**，在C99中合法。但该写法已非常常见。

```c
for (int i = 0; i < 5; i++) printf("%d\n", i);
```

C89应在循环初始化外声明所需变量。

```c
int i;
for (i = 0; i < 5; i++) printf("%d\n", i);
```

## 第四章 数组和串

### 4.3 向函数传一维数组

在接受数组的函数中，定义数组形参的方法有三种：**指针**，**定尺寸数组**，**无尺寸数组**。以下效果等同：

```c
void func1(int* x);
void func2(int x[10]);
void func3(int x[]);
```

三种声明都是在告诉函数要接受一个整型数组了。但C语言中并不能把一整个数组传入函数，所以它们**实际接收的都是一个指针**。且因为C语言不进行边界检查，所以参数有没有尺寸也无所谓，并不会引起内存分配。

### 4.5 二维数组

在向函数传递二维数组时，形参的定义中，第一维可以没有大小，但第二维必须要有，如下：

```c
void func(int x[][10]);
```

因为要告诉程序每一行有多长，程序才能正确计算二维坐标。（多维数组同理）

### 4.7 指针的下标操作

对于数组`char p[10]`，`p`等同于`&p[0]`，而专业的C程序中不会出现后者。

为了正确运算指针算术（后面几章会有），将数组指针转换为基类型指针的算法是必不可少的。有时，程序中通过指针运算操作数组，原因在于**指针运算一般快于数组下标**。

>   既然`p`等同于`&p[0]`，那为什么要转换数组指针为基类型指针呢？（`(int*)&p[0]`）
>
>   例如，对于二维数组`int a[10][10]`，要取`a[1][2]`，还可以`*((int*)a+12)`。既然`a`本身就是一个指针，又为什么要强制转换为`int*`呢？

### 4.8 数组初始化

C99允许非常量初始化字符用于本地数组，而C89要求常量初始化字符用于所有数组。

>   啥叫本地数组？
>
>   **答：本地数组是指带有块域或原型域的数组。**
>
>   自我理解：大概就是不能是全局数组？

```c
void func(int dim)
{
    char str[dim];
    /* statements */
}
```

## 第五章 指针

### 5.4 指针表达式

#### 5.4.2 指针转换

指针操作是相对指针的基类型而执行的。虽然技术上指针可以指向对象的其它类型，但它始终认为自己指向的是其基类型的对象。因此强制指针转换可能会出现各种问题。

```c
#include <stdio.h>

int main(void)
{
    double x = 100.1, y;
    int* p;
    p = (int*)&x;
    y = *p;
    printf("%f\n", y); //并不能得到正确的结果
    return 0;
}
```

虽然在C语言中由其它类型指针转到`void*`类型或者反过来都不会有问题，但C++中非强制转换的各种转换都是非法的，包括`void*`，所以一般来说在C程序中也舍弃了所有的指针转换。

**务必确保指针操作的对象与基类型兼容。**

#### 5.4.3 指针算术操作

可以施加于指针的算术操作只有**加法**和**减法**。

实际上指针可以参与的算术屈指可数，只有**增量**，**减量**，**指针加减整数**，**指针相减**。

### 5.5 指针和数组

#### 5.5.1 指针数组

指针数组的声明方式、赋值、取值：

```c
int* x[10];
x[2] = &var;
v = *x[2];
```

向函数传指针数组的参数：

```c
void display_array(int* q[])
{
    int t;
    for (t = 0; t < 10; t++)
        printf("%d\n", *q[t]);
}
```

注意，上述函数形参不能写成`int* q`。

指针数组常用于放置指向串的指针，例如：

```c
void syntax_error(int num)
{
    static char* err[] = {
        "Cannot open file.\n",
        "Read Error.\n",
        "Write Error.\n",
        "Media Failure.\n"
    }
    printf("%s", err[num]);
}
```

### 5.7 指针初始化

在python中，创建和使用一个字符串列表很容易也很方便，但C语言中并没有特别提供字符串类型，所以一般的字符串数组像这样声明：

```c
char* str[] = {"hello", "world", NULL};
```

没错这就是一个指针数组，如上节所言。

但通常会在串数组最后加一个常量`NULL`（该常量定义在`stdio.h`头文件中），用来告诉程序数组到这里结束了。

遍历时如下：

```c
for (int i = 0; str[i]; i++) printf("%s\n", str[i]);
```

如果数组最后没有`NULL`，可能会发生一些不了解的问题，例如不能退出遍历等。

同样的，对于创建字符串，通常用这些方式：

```c
char s[] = "hello";
char* t = "world";
```

可以看出，`s`和`t`实际都是指针，而指针是不能存储一整个字符串的。那个字符串实际被存到哪了呢？

C编译程序创建了一种叫“串表”的东西，用来存储字符串，然后把串表的地址传给指针。这样就可以用指针操作字符串了。

```c
printf("%s, %s", s, t);
```

### 5.8 函数指针

函数名也是函数的地址，跟数组名是数组地址相同。所以当把一个指针指向一个函数地址时，就可以通过指针调用函数。

函数指针的声明方式：

```c
int (*p)(const char*, const char*);
```

这个声明表示这个函数指针名字叫`p`，有两个参数，都是`const char*`，返回值是`int`类型。参数，名字和返回值都可变，但声明方式固定。

注意，`(*p)`中的**括号一定不能省略**。

在调用时，假设两个参数为`a` `b`，则有两种方式：

```c
(*p)(a, b);
p(a, b);
```

通常**使用第一种方式**，因为读代码的人在看到第一种调用时可以明确知道`p`是一个函数指针而非函数名。

函数指针常用于函数传参。这样不同的函数名可以传入同一函数内用一条语句统一调用。

### 5.9 动态分配函数

动态分配是程序在运行中获取内存的方法。全局变量在编译时分配，非静态局部变量使用栈空间，两者都不能在运行时增减。但有些程序可能在运行时需要大小可变的空间，比如动态数据结构链表或者二叉树等。

动态分配函数从堆中获取内存。堆是一个系统的自由内存区，一般很大。

动态分配系统的核心函数只有`malloc()`和`free()`。两者都包含在头文件`stdlib.h`中。

`malloc()`的原型是

```c
void* malloc(size_t number_of_bytes);
```

由此看出，该函数返回一个`void*`类型。该类型在C语言中可以非强制转换成其它指针类型，所以可以这样使用

```c
char* p;
p = malloc(1000);
```

`malloc(1000)`返回了一个`void*`类型，赋给了`char*`类型的变量，并不会报错。但在C++中是不行的，需要加强制转换。而且，为了让C程序与C++兼容，**现在也会在C程序里加强制转换**。所以上例：

```c
char* p;
p = (char*)malloc(1000);
```

由于有些数据类型，比如`int`会由于系统不同而占据不同的空间大小，所以通常申请内存会这个样子处理

```c
p = malloc(50*sizeof(int));
```

这样申请了50个整数的空间大小，还保证了可移植性。

虽然堆很大，但也是有限的，所以最好在申请内存后检查一下是否真的分配到了空间。如果分配到了，`malloc()`会返回空间的首地址，如果没有，则会返回`NULL`。所以可以这样检查

```c
p = malloc(100);
if (!p)
{
    printf("Out of memory!\n");
    exit(1);
}
```

`exit(1)`处可以用其它错误处理函数替代，总之就是要防止使用空指针。

`free()`是`malloc()`的逆函数，它将后者申请到的内存再释放回去。原型是

```c
void free(void* p);
```

`p`指向原先`malloc()`分配到的内存指针。

注意，**绝不能用无效指针调用`free()`**。

#### 5.9.1 动态分配的数组

```c
int (*p)[10];
```

>   没搞明白这个定义到底是什么意思，后面再来补坑吧。

### 5.10 由restrict修饰的指针

`restrict`是C99标准新加的仅适用于指针的类型修饰符，将在后面详细介绍。

### 5.11 与指针有关的问题

指针错误的性质特别严重，且通常难以排查，应全力防止。以下研究几种指针错误的例子。

**使用未初始化的指针**：

```c
int main(void)
{
    int x, * p;
    x = 10;
    *p = x; //err
    return 0;
}
```

未初始化指针，程序会给指针随机分配地址，在地址充足的情况下，通常会分配到安全地址，但随着程序和数据越来越多，难免分配到不安全的地址，如系统地址。所以要严格避免这种情况。

**错误理解指针**：

```c
#include <stdio.h>

int main(void)
{
    int x, * p;
    x = 10;
    p = x;
    printf("%d", *p);
    return 0;
}
```

此程序相当于把地址编号10赋给了`p`，而这个地址是未知的，通常输出不确定。`p = x`应为`p = &x`。

**认为相邻数组顺序排列**：

```c
int main(void)
{
    int first[5], second[5];
    int * p, t;
    p = first;
    for (t = 0; t < 10; t++) *p++ = t; //err
    return 0;
}
```

实际上两个数组不一定相邻，也不一定`first`总在`second`前面，所以不能在同一个循环里赋值。

**一个严重的BUG**：

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[80];
    char* p;
    p = s;
    do
    {
        gets_s(s, 80);
        while (*p) printf("%d\n", *p++);
    } while (strcmp(s, "done"));
    return 0;
}
```

此段程序本意在于每次获取一段字符串就输出，但错误在于`p = s`在循环外，这说明它只被设置一次，而在循环内，在输出字符串后，指针`p`的地址已经到了字符串的末尾而未得到重置，可能就会超出串的长度限制，将数据覆盖到其它变量或其它程序。这是个简单却严重的循环错误，解决办法就是把`p = s`放到`do`循环内第一行。

## 第六章 函数

### 6.3 函数的变元

变元就暂时理解为跟函数形参相对的实际参数吧。

#### 6.3.1 值调用和引用调用

像函数形参传递值时有两种方法，值调用传递的是**变元的拷贝**，函数内修改形参不会改变变元；引用调用传递的是**变元地址**，在函数内通过地址访问对象，对对象的修改也会改变变元。

一般来说，C使用值调用向函数传递变元，这样函数内就不能修改实参。

```c
#include <stdio.h>

int sqr(int x)
{
    x = x * x;
    return x;
}

int main(void)
{
    int t = 10;
    printf("%d %d", sqr(t), t); //t还是10
    return 0;
}
```

#### 6.3.2 引用调用

下面是一个引用调用的例子：

```c
#include <stdio.h>

void swap(int* x, int* y)
{
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

int main(void)
{
    int i = 10, j = 20;
    printf("before: %d %d\n", i, j);
    swap(&i, &j); //注意传递的是地址
    printf("after: %d %d\n", i, j);
    return 0;
}
```

#### 6.3.3 用数组调用

向函数传递数组时，实际传递的是数组的地址，所以这是一个标准值调用的例外。这种情况下，函数内对数组的修改实际是修改了真正的数组（这跟python列表作函数参数时相似），观察下例

```c
#include <stdio.h>
#include <ctype.h>

void print_upper(char* s)
{
    for (int i = 0; s[i]; i++)
    {
        s[i] = toupper(s[i]);
        putchar(s[i]);
    }
    printf("\n");
}


int main(void)
{
    char str[80];
    gets_s(str, 80);
    print_upper(str);
    printf("%s\n", str); //实际数组也被修改了
    return 0;
}
```

如果不想修改实际的数组，可以把`print_upper()`中`for`循环内的语句换成`putchar(toupper(s[i]))`。

### 6.4 main()的变元argc和argv

有时需要向程序传入信息。我们一般通过命令行变元向主函数`main()`传递信息。命令行变元是操作系统命令行中执行程序名字之后的信息。

有两个内设参量用于接受命令行变元，一个是`argc`，另一个是`argv`。`argc`是整型变量，存放命令行中变元的总数，因为程序名也算一个，所以`argc`的值最小为1；`argv`是指针，指向由字符串指针组成的数组（即字符串数组），数组中每个元素指向一个命令行变元，所有命令行变元都是字符串。观察下例

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
	if (argc != 2)
	{
		printf("You have to type your name!\n");
		exit(1);
	}
	printf("Hello %s\n", argv[1]); //第一个命令行变元(即argv[0])总是程序的名字
	return 0;
}
```

**注意`argv`的声明方式**。假设文件名叫`temp.c`，在命令行中输入如下语句

```
PC > gcc temp.c -o temp.exe
PC > ./temp.exe Julian
Hello Julian
```

注意，命令行变元之间必须用**空格**或**制表符**分隔，逗号和分号都不是分隔符。

### 6.5 返回语句

#### 6.5.3 返回指针

返回指针的函数必须明确声明返回的指针类型。

```c
#include <stdio.h>

char* match(char c, char* s)
{
	while (c != *s && *s) s++;
	return s; //返回一个地址或者NULL
}

int main(void)
{
	char s[10], * p, ch;
	gets_s(s, 10);
	ch = getchar();
	p = match(ch, s);
	if (p) printf("%s\n", p);
	else printf("Not found\n");
	return 0;
}
```

### 6.7 递归

```c
#include <stdio.h>

int factr(int n)
{
	if (n == 1) return 1;
	int answer = factr(n - 1) * n;
	return answer;
}

int main(void)
{
	printf("%d\n", factr(10));
	return 0;
}
```

C语言不能在函数内再声明函数（python可以，比如装饰器），但是可以在函数内调用函数（当然了），也包括调用自己。

很多情况下递归的速率并不比迭代快，反而会很慢，因为调用的开销很大，还可能导致堆栈溢出。但递归在解决某些算法问题时要比迭代容易得多。

### 6.8 函数原型

```c
#include <stdio.h>

int sqr(int n);

int main(void)
{
	int x = 10;
	printf("%d %d\n", sqr(x), x);
	return 0;
}

int sqr(int n)
{
	return n * n;
}
```

第二行的`int sqr(int n);`就叫做函数原型。当然如果函数在主函数之前定义了，那么函数定义可以充当函数原型。但那样不规范，如果是文件很大，函数很多的C程序，或者是有很多文件的程序，最好把函数原型写在前面。

**原型能使编译程序提供更强的类型检查**。虽然在C程序中不是必需的，但**在C++中是必需的**。

在C和C++中对函数原型的处理有细微但重要的区别。在C程序中，如果函数原型如下

```c
int func();
```

表示该函数的参数列表没有给出，并不代表没有参数。如果没有参数的话会在参数列表填写一个`void`。但在C++中，空参数列表即代表没有参数，所以`void`就很多余了。

### 6.9 定义可变长度的参数表

可以定义参数的类型和数量都可变的函数。为了把传递给一个函数的未知变元数告诉编译程序，我们用三个圆点结束函数形参的声明。例

```c
int func(int n, ...);
```

函数定义也可以使用这种声明。

注意，使用可变参数值的任何函数，**至少必须有一个实际的参数**。如下例是非法的

```c
int func(...); //illegal
```

### 6.10 “隐含的int”规则

在C89及以前的C版本中，如果一个函数没有声明返回值类型，则默认为`int`类型。但该特性已在C99和C++中舍弃，**强烈不建议在C89版本中省略返回值类型声明，最好还是明确声明**。

### 6.11 参数声明的老式方法和现代方法

```c
//现代方法
float func(int a, int b, char ch)
{
    /* ... */
}
//老式方法
float func(a, b, ch)
int a, b;
char ch;
{
    /* ... */
}
```

标准C已命令废弃老式的参数声明方法，但有些早期C程序还这样写，所以认识就好，**不要这样写**，而且C++中仅支持现代方法。

### 6.12 inline关键字

C99新加的用于函数的关键字`inline`，可以优化对函数的调用，后面再说。

## 第七章 结构、联合、枚举和用户定义类型

### 7.1 结构

结构是在一个名下引用的多种变量的集合，提供一种把相关数据组合到一起的方便手段。构成结构的变量成为成员，或者元素或者域。通常，结构中的诸成员都是逻辑相关的。例

```c
struct person
{
    char name[30];
    short age;
    char sex[10];
};
```

注意，**定义结尾有分号**！因为结构定义也是C语句。在这里`person`是结构标记，标识这一特定的数据结构，是结构的类型标识符。也就是说，我们定义了一种新的数据类型！

在结构定义过程中没有任何变量产生，我们声明这种新类型的变量时，可以这样

```c
struct person student;
```

这里，`student`就是一个`struct person`型的结构变量。即`person`描述结构，`student`描述对象/实例。

定义结构变量后，程序就会自动为结构的所有成员分配足够的内存。

定义结构的同时可以定义一个或多个对象。

```c
struct person
{
    char name[30];
    short age;
    char sex[10];
} student, teacher;
```

此时各个结构变量中的成员都有自己单独的内存，它们是相互独立的，不同的。改变一者不会影响另一者。

而如果只需要一个结构变量，则结构标记可以省略，如

```c
struct
{
    char name[30];
    short age;
    char sex[10];
} student;
```

结构标记和结构变量可以二选一，但必须有一。

#### 7.1.1 存取结构成员



